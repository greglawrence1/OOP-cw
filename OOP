import java.awt.Color;
import java.awt.FlowLayout;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;

import javax.imageio.*;
import javax.swing.JFrame;
import uk.ac.leedsbeckett.oop.LBUGraphics;



public class GraphicsSystem extends LBUGraphics
{
	Validator Validator1 = new Validator();
	
        public GraphicsSystem()
        {
            JFrame MainFrame = new JFrame();           
            MainFrame.setLayout(new FlowLayout());      
            MainFrame.add(this);                                        
            MainFrame.pack();                                           
            MainFrame.setVisible(true); 
            turnLeft(90);
        }
        
 		@Override
 		public void processCommand(String command)     
        {
 						
                String[] commands = command.split(" ");
                if (Validator1.CommandValid(commands[0]) == false)
                {
                	System.out.println("Incorrect Command");
                	return;
                }
                
                {
                switch (commands[0]) 
                {
                case "about":
                	about();
                	break;             	
                case "penUp":
                	Boolean penUp1 = true;
                	Boolean penDown1 = false;
                	if(penUp1)
                	{
                		penUp();
                	}
                	if(penDown1)
                	{
                		penDown();
                	}
                	break;
                case "penDown":
                	Boolean penDown2 = true;
                	Boolean penUp2 = false;
                	if(penDown2)
                	{
                		penDown();
                	}
                	if(penUp2)
                	{
                		penUp();
                	}
                	break;
                case "clear":
                	clear();
                	break;
                case "reset":
                	reset();
                	turnLeft(90);
                	break;
                case "turnLeft":
                	String left = commands[1];
                	try {
	                	int lefty = Integer.parseInt(left);
	                	if (lefty > 0 && lefty < 1000)
	                	{
	                	turnLeft(lefty);
	                	}
	                	else if (lefty <= 0 || lefty > 1000 )
	                	{
	                		System.out.println("Out of the Range 1 - 999");
	                	}
                	}
                	catch (NumberFormatException e) {
                		System.out.println("This is Not a Number");
                	}
                	break;
				case "turnRight":
                	String right = commands[1];
                	try {
	                	int righty = Integer.parseInt(right);
	                	if (righty > 0 && righty < 1000)
	                	{
	                	turnRight(righty);
	                	}
	                	else if (righty <= 0 || righty > 1000 )
	                	{
	                		System.out.println("Out of the Range 1 - 999");
	                	}
                	}
	                catch (NumberFormatException e){
	                	System.out.println("This is Not A Number");
	                }	                	
                	break;
                case "forward":
                	String forwards = commands[1];
	                try {
                		int onward = Integer.parseInt(forwards);
	                	if (onward > 0 && onward < 1000)
	                	{
	                	forward(onward);
	                	}
	                	else if (onward <= 0 || onward > 1000 )
	                	{
	                		System.out.println("Out of the Range 1 - 999");
	                	}
	                }
	                catch (NumberFormatException e) {
	                	System.out.println("This is Not a Number");
	                }
                	break;
                case "backward":
                	String backwards = commands[1];
	                try {	
                		int back = Integer.parseInt(backwards);
	                	back = -back;
	                	if (-back > 0 && -back < 1000)
	                	{
	                	forward(back);
	                	}
	                	else if (-back <= 0 || -back > 1000 )
	                	{
	                		System.out.println("Out of the Range 1 - 999");
	                	}
	                }
	                catch (NumberFormatException e) {
	                	System.out.println("This is Not a Number");
	                }
                	break;
                case "green":
                	setPenColour(Color.green);
                	break;
                case "red":
                	setPenColour(Color.red);
                	break;
                case "white":
                	setPenColour(Color.white);
                	break;
                case "orange":
                	setPenColour(Color.orange);
                	break;
                case "save":
            		try
            		{
            		    BufferedImage br = getBufferedImage();
            		    File file = new File("TurtleImg.png");
            		    ImageIO.write(br, "png", file);
            		} catch (IOException e) {
            		break;
            		}
                case "load":  
                	BufferedImage img = null;
                	try {
                	    BufferedImage imgage = ImageIO.read(new File("TurtleImg.png"));
                	    setBufferedImage(imgage);
                	} catch (IOException e) {
                	{
                	break;
                	}
        }

}
}
}
}


public class Driver {

		 public static void main(String[] args)
	        {
	                new GraphicsSystem(); 
	        }
		
	}
import java.util.Arrays;

public class Validator {
    
	private final String[] VALID_COMMANDS = 
    	{"reset", "turnLeft", "turnRight", "penUp", 
    		"penDown", "forward", "clear", "backward",
    		"green", "orange", "red", "white", "save", "load", "about"};

	public Validator()
	{
		
	}
	
	boolean CommandValid(String command)
	{
		boolean valid = Arrays.stream(VALID_COMMANDS).anyMatch(command::equals);
		
		return valid;
	}

}

